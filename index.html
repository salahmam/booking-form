
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ø³ÙˆØ¯ÙˆÙƒÙˆ â€”   (  )</title>
  <style>
    :root{
      --bg: #0f0f12;
      --card: #181a1f;
      --ink: #e9eef6;
      --muted: #aeb7c8;
      --accent: #00d8ff;
      /* Yalla Ludo palette */
      --red: #ea3b2d;
      --blue: #2f7bff;
      --green: #27c93f;
      --yellow: #ffcc00;

      --cell: #1f232b;
      --cell-focus: #263043;
      --cell-border: #2f3644;

      --ok: #2bd576;
      --bad: #ff5d5d;

      --btn: #202735;
      --btn-hover: #2a3446;
    }

    *{ box-sizing: border-box; }

    body{
      margin: 0;
      background:
        radial-gradient(1200px 600px at 10% -10%, rgba(255,0,0,.2), transparent 60%),
        radial-gradient(1200px 600px at 110% 10%, rgba(0,255,0,.15), transparent 60%),
        radial-gradient(1200px 600px at -10% 100%, rgba(0,0,255,.18), transparent 60%),
        radial-gradient(1200px 600px at 120% 120%, rgba(255,215,0,.18), transparent 60%),
        var(--bg);
      color: var(--ink);
      font-family: "Tajawal", "Cairo", "Noto Kufi Arabic", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      min-height: 100dvh;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 14px;
    }

    header{
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 16px 12px;
      position: sticky;
      top: 0;
      backdrop-filter: blur(8px);
    }

    .wrap{
      width: min(1100px, 92vw);
      margin: 0 auto;
    }

    .title{
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }
    .badge{
      padding: 6px 10px;
      font-weight: 700;
      border-radius: 10px;
      background: linear-gradient(135deg, var(--green), var(--yellow));
      color: #102312;
      box-shadow: 0 6px 16px rgba(39,201,63,.32);
    }
    h1{
      margin: 0;
      font-weight: 800;
      letter-spacing: .3px;
      text-shadow: 0 6px 30px rgba(0,0,0,.35);
    }

    .hud{
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 10px;
      align-items: center;
      margin-top: 14px;
    }

    .controls{
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    select, button{
      background: var(--btn);
      border: 1px solid var(--cell-border);
      color: var(--ink);
      padding: 10px 14px;
      border-radius: 12px;
      font-size: 16px;
      cursor: pointer;
      transition: transform .12s ease, background .2s ease, box-shadow .2s ease;
      box-shadow: 0 6px 20px rgba(0,0,0,.25);
    }
    button:hover, select:hover{ background: var(--btn-hover); }
    button:active{ transform: translateY(1px) scale(.99); }

    .pill{
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px dashed var(--cell-border);
      color: var(--muted);
      font-weight: 600;
      background: #161a21;
    }

    .game{
      display: grid;
      grid-template-columns: 1fr;
      justify-items: center;
      gap: 18px;
      margin: 8px 0 26px;
    }

    .board{
      width: min(92vw, 530px);
      aspect-ratio: 1/1;
      background: linear-gradient(180deg, #151821, #10131a);
      border-radius: 18px;
      padding: 12px;
      box-shadow:
        0 12px 30px rgba(0,0,0,.45),
        inset 0 0 0 1px rgba(255,255,255,.03);
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(9, 1fr);
      gap: 2px;
      position: relative;
      overflow: hidden;
    }

    .cell{
      display: grid;
      place-items: center;
      font-size: clamp(18px, 3.2vw, 26px);
      font-weight: 800;
      background: var(--cell);
      border: 1px solid var(--cell-border);
      border-radius: 9px;
      transition: background .15s ease, transform .07s ease, box-shadow .2s ease;
      outline: none;
      caret-color: transparent;
      user-select: none;
    }
    .cell[data-editable="true"]{
      background: #1b2130;
      cursor: pointer;
    }
    .cell:focus-visible{
      outline: 2px solid var(--accent);
      box-shadow: 0 0 0 6px rgba(0,216,255,.08);
    }
    .cell[data-selected="true"]{
      background: var(--cell-focus);
      transform: scale(1.02);
    }

    /* thick borders for 3x3 boxes (kept as in original design) */
    .cell[data-r="2"], .cell[data-r="5"]{ border-bottom: 2px solid var(--ink); }
    .cell[data-c="2"], .cell[data-c="5"]{ border-right: 2px solid var(--ink); }

    /* box coloring (Yalla Ludo vibe) */
    .cell[data-box="0"], .cell[data-box="8"]{ background-image: linear-gradient(145deg, rgba(39,201,63,.10), rgba(39,201,63,.04)); }
    .cell[data-box="1"], .cell[data-box="7"]{ background-image: linear-gradient(145deg, rgba(255,204,0,.10), rgba(255,204,0,.04)); }
    .cell[data-box="2"], .cell[data-box="6"]{ background-image: linear-gradient(145deg, rgba(47,123,255,.12), rgba(47,123,255,.05)); }
    .cell[data-box="3"], .cell[data-box="5"]{ background-image: linear-gradient(145deg, rgba(234,59,45,.12), rgba(234,59,45,.05)); }
    .cell[data-box="4"]{ background-image: linear-gradient(145deg, rgba(0,216,255,.10), rgba(0,216,255,.04)); }

    .legend{
      display: grid;
      grid-template-columns: repeat(5, max-content);
      gap: 8px 14px;
      align-items: center;
      justify-content: center;
    }
    .dot{
      width: 12px; height: 12px; border-radius: 50%;
      display: inline-block; margin-inline-start: 4px;
    }
    .red{ background: var(--red); }
    .blue{ background: var(--blue); }
    .green{ background: var(--green); }
    .yellow{ background: var(--yellow); }
    .aqua{ background: var(--accent); }

    .footer{
      color: var(--muted);
      text-align: center;
      padding: 16px 10px 30px;
      font-size: 14px;
    }

    /* animations */
    @keyframes shake{
      10%{ transform: translateX(-2px); }
      20%{ transform: translateX(2px); }
      30%{ transform: translateX(-2px); }
      40%{ transform: translateX(2px); }
      50%{ transform: translateX(-2px); }
      60%{ transform: translateX(2px); }
      100%{ transform: translateX(0); }
    }
    .shake{ animation: shake .35s linear both; }

    @keyframes pop{
      0%{ transform: scale(.9); }
      100%{ transform: scale(1); }
    }
    .pop{ animation: pop .12s ease-out; }

    .wrong{
      background: linear-gradient(180deg, rgba(255,93,93,.15), rgba(255,93,93,.05));
      border-color: rgba(255,93,93,.8) !important;
    }

    .correct{
      background: linear-gradient(180deg, rgba(43,213,118,.18), rgba(43,213,118,.07));
      border-color: rgba(43,213,118,.9) !important;
    }

    .toolbar{
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .btn-cta{
      background: linear-gradient(135deg, var(--green), var(--yellow));
      color: #103313;
      border: none;
      font-weight: 800;
      letter-spacing: .3px;
      box-shadow: 0 10px 28px rgba(39,201,63,.35);
    }
    .btn-cta:hover{ filter: brightness(1.05); }
    .btn-danger{
      background: linear-gradient(135deg, #ff6a6a, #ea3b2d);
      border: none;
      color: #fff;
      font-weight: 800;
      box-shadow: 0 10px 28px rgba(234,59,45,.35);
    }
    .btn-secondary{
      background: linear-gradient(135deg, #2f7bff, #00d8ff);
      border: none;
      color: #041225;
      font-weight: 800;
      box-shadow: 0 10px 28px rgba(47,123,255,.35);
    }

    .progress{
      height: 10px;
      background: #11151b;
      border: 1px solid var(--cell-border);
      border-radius: 999px;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }
    .progress > div{
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--blue), var(--accent));
      transition: width .3s ease;
    }

    .timer{
      text-align: center;
      font-weight: 700;
      letter-spacing: .4px;
    }

    /* confetti canvas */
    #confetti{
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    @media (max-width: 480px){
      .legend{ grid-template-columns: repeat(3, max-content); }
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap title">
      <span class="badge">Ø³ÙˆØ¯ÙˆÙƒÙˆ</span>
      <h1>  HELLEN ğŸ¦‹   </h1>
    </div>
  </header>

  <main class="wrap">
    <div class="selectors">
  <label>Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰:</label>
  <select id="levelSelect">
    <option value="1">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 1</option>
    <option value="2">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 2</option>
    <option value="3">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 3</option>
    <option value="4">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 4</option>
    <option value="5">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 5</option>
    <option value="6">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 6</option>
  </select>

  <label>Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø©:</label>
  <select id="stageSelect">
    <option value="1">Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1</option>
    <option value="2">Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2</option>
    <option value="3">Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3</option>
    <option value="4">Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4</option>
    <option value="5">Ø§Ù„Ù…Ø±Ø­Ù„Ø© 5</option>
    <option value="6">Ø§Ù„Ù…Ø±Ø­Ù„Ø© 6</option>
    <option value="7">Ø§Ù„Ù…Ø±Ø­Ù„Ø© 7</option>
    <option value="8">Ø§Ù„Ù…Ø±Ø­Ù„Ø© 8</option>
    <option value="9">Ø§Ù„Ù…Ø±Ø­Ù„Ø© 9</option>
    <option value="10">Ø§Ù„Ù…Ø±Ø­Ù„Ø© 10</option>
  </select>

  <button onclick="startGame()">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
</div>

<script>
function startGame() {
  let level = document.getElementById("levelSelect").value;
  let stage = document.getElementById("stageSelect").value;
  // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…Ø¹ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ÙˆØ§Ù„Ù…Ø±Ø­Ù„Ø©
  console.log("Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø³ØªÙˆÙ‰: " + level + " - Ø§Ù„Ù…Ø±Ø­Ù„Ø©: " + stage);
}
</script>

      <div class="timer" id="timer">00:00</div>

      <div class="controls" style="justify-content: flex-end;">
        <div style="min-width: 180px;">
          <div class="progress" title="Ø§Ù„ØªÙ‚Ø¯Ù‘Ù…">
            <div id="progressBar"></div>
          </div>
        </div>
      </div>
    </div>

    <section class="game">

      <!-- Ù…Ø³Ø§Ø­Ø© Ø¥Ø¹Ù„Ø§Ù† Google (Ù…ÙƒØ§Ù† ÙÙ‚Ø· Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ± Ø§Ù„ØªØµÙ…ÙŠÙ…) -->
      <div id="adBanner" style="width:min(92vw,728px);height:90px;background:#11151b;border:1px dashed var(--cell-border);border-radius:12px;display:flex;align-items:center;justify-content:center;color:var(--muted)">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-xxxxxxxx"
  crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-xxxxxxxx"
     data-ad-slot="1234567890"
     data-ad-format="auto"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
        <!-- Ø¶Ø¹ ÙƒÙˆØ¯ AdSense Ù‡Ù†Ø§ Ø¹Ù†Ø¯ Ø§Ù„Ù†Ø´Ø± --> 
      </div> 

      <div class="board" id="board" role="grid" aria-label="Ø´Ø¨ÙƒØ© Ø³ÙˆØ¯ÙˆÙƒÙˆ">
        <canvas id="confetti"></canvas>
      </div>

      <div class="toolbar">
        <button class="btn-cta" id="btnCheck">ØªØ­Ù‚Ù‘Ù‚</button>
        <button class="btn-secondary" id="btnNext">Ø§Ù„ØªØ§Ù„ÙŠ â®•</button>
        <button class="btn-danger" id="btnReset">Ø¥Ø¹Ø§Ø¯Ø©</button>
      </div>

      <div class="legend">
        <span><span class="dot green"></span> Ù…Ø±Ø¨Ø¹Ø§Øª 3Ã—3 Ù…Ù„ÙˆÙ‘Ù†Ø©</span>
        <span><span class="dot yellow"></span> Ø®Ù„ÙŠØ© Ù…Ø¨Ø¯Ø¦ÙŠØ©</span>
        <span><span class="dot blue"></span> ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø®Ù„ÙŠØ©</span>
        <span><span class="dot aqua"></span> ØªÙ„Ù…ÙŠØ­Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø©</span>
        <span><span class="dot red"></span> Ø£Ø®Ø·Ø§Ø¡</span>
      </div>
    </section>
  </main>

  <footer class="footer">
    ØµÙ†Ø¹ Ø¨Ø­Ø¨ â€”    <b>â¤ï¸ </b>. Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ù…Ù† 1 Ø¥Ù„Ù‰ 9 ÙÙ‚Ø·. Ø¨Ø§Ù„ØªÙˆÙÙŠÙ‚! âœ¨
  </footer>

  <!-- Ø£ØµÙˆØ§Øª -->
  <audio id="clickSound" src="https://assets.mixkit.co/sfx/download/mixkit-interface-click-1126.wav" preload="auto"></audio>
  <audio id="winSound" src="https://assets.mixkit.co/sfx/download/mixkit-achievement-bell-600.wav" preload="auto"></audio>

  <script>
    /************** Utilities **************/
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const boardEl = $("#board");
    const stageSel = $("#stage");
    const statusEl = $("#status");
    const progressEl = $("#progressBar");
    const timerEl = $("#timer");
    const btnCheck = $("#btnCheck");
    const btnNext = $("#btnNext");
    const btnReset = $("#btnReset");
    const confettiCanvas = $("#confetti");
    const ctx = confettiCanvas.getContext("2d");
    const clickSound = $("#clickSound");
    const winSound = $("#winSound");

    let SIDE = 9;
    // box rows/cols pair â€” depends on SIDE
    let BOX_R = 3, BOX_C = 3;

    let currentLevel = 1; // 1..6
    let currentStage = 1; // 1..10 within each level

    let initialBoard = []; // zeros for blanks
    let solutionBoard = [];
    let startTime = null, timerInt = null;

    function playClick(){ try{ clickSound.currentTime = 0; clickSound.play(); }catch{} }
    function playWin(){ try{ winSound.currentTime = 0; winSound.play(); }catch{} }

    function formatTime(sec){
      const m = Math.floor(sec/60).toString().padStart(2,'0');
      const s = (sec%60).toString().padStart(2,'0');
      return `${m}:${s}`;
    }
    function startTimer(){
      if(timerInt) clearInterval(timerInt);
      startTime = Date.now();
      timerInt = setInterval(()=>{
        const elapsed = Math.floor((Date.now()-startTime)/1000);
        timerEl.textContent = formatTime(elapsed);
      }, 1000);
    }
    function stopTimer(){ if(timerInt){ clearInterval(timerInt); timerInt = null; } }

    /************** Level/Stage mapping **************/
    // Level 1..6 => SIDE 4..9
    function sideForLevel(lvl){ return 3 + Math.max(1, Math.min(6, lvl)); } // 1->4, 6->9
    // box shape per SIDE (R x C); for primes fall back to no boxes (1 x SIDE)
    function boxShapeFor(side){
      const map = {
        4: [2,2],
        5: [1,5],
        6: [2,3],
        7: [1,7],
        8: [2,4],
        9: [3,3]
      };
      return map[side] || [1, side];
    }

    /************** Sudoku Gen/Solve **************/
    // generalized pattern that respects rectangular boxes if BOX_R*BOX_C == SIDE
    function pattern(r,c, R, C, N){ return (C*(r%R) + Math.floor(r/R) + c) % N; }

    function shuffle(arr){
      const a = [...arr];
      for(let i=a.length-1; i>0; i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }

    function generateFull(N, R, C){
      // If R*C != N (prime sizes), generate Latin square (row/col rules only)
      if(R*C !== N){
        const base = [...Array(N).keys()]; // 0..N-1
        const rows = shuffle(base);
        const cols = shuffle(base);
        const nums = shuffle([1,2,3,4,5,6,7,8,9].slice(0,N));
        const board = Array.from({length:N}, (_,r)=>Array.from({length:N}, (_,c)=> nums[(rows[r] + cols[c]) % N]));
        return board;
      }
      // standard box-friendly board
      const rBase = [...Array(R).keys()], cBase = [...Array(C).keys()];
      const rows = [].concat(...shuffle(rBase).map(g=>shuffle(rBase).map(r=>g*R+r)));
      const cols = [].concat(...shuffle(cBase).map(g=>shuffle(cBase).map(c=>g*C+c)));
      const nums = shuffle([1,2,3,4,5,6,7,8,9].slice(0,N));
      const board = Array.from({length:N}, (_,r)=>Array.from({length:N}, (_,c)=> nums[pattern(rows[r], cols[c], R, C, N)]));
      return board;
    }

    function copyBoard(b){ return b.map(row=>row.slice()); }

    function removeCells(board, blanks){
      const b = copyBoard(board);
      let removed = 0;
      const N = board.length;
      const cells = shuffle([...Array(N*N).keys()]);
      for(const idx of cells){
        if(removed>=blanks) break;
        const r = Math.floor(idx/N), c = idx%N;
        if(b[r][c] !== 0){
          b[r][c] = 0;
          removed++;
        }
      }
      return b;
    }

    function isValidMove(board, r,c, num){
      const N = board.length;
      // row & col
      for(let i=0;i<N;i++){
        if(board[r][i]===num && i!==c) return false;
        if(board[i][c]===num && i!==r) return false;
      }
      // box (only if boxes are defined nicely)
      if(BOX_R*BOX_C === N && BOX_R>1 && BOX_C>1){
        const br = Math.floor(r/BOX_R)*BOX_R;
        const bc = Math.floor(c/BOX_C)*BOX_C;
        for(let i=0;i<BOX_R;i++){
          for(let j=0;j<BOX_C;j++){
            const rr=br+i, cc=bc+j;
            if(board[rr][cc]===num && (rr!==r || cc!==c)) return false;
          }
        }
      }
      return true;
    }

    function solveBoard(board){
      const b = copyBoard(board);
      const N = b.length;
      function findEmpty(){
        for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(b[r][c]===0) return [r,c];
        return null;
      }
      function backtrack(){
        const pos = findEmpty();
        if(!pos) return true;
        const [r,c] = pos;
        for(let n=1;n<=N;n++){
          if(isValidMove(b, r,c, n)){
            b[r][c]=n;
            if(backtrack()) return true;
            b[r][c]=0;
          }
        }
        return false;
      }
      return backtrack() ? b : null;
    }

    /************** Rendering **************/
    function boxIndex(r,c){
      if(BOX_R*BOX_C !== SIDE || BOX_R===1 || BOX_C===1) return -1;
      return Math.floor(r/BOX_R)*BOX_C + Math.floor(c/BOX_C);
    }

    function buildBoard(puzzle){
      boardEl.innerHTML = "";
      // set grid size
      boardEl.style.gridTemplateColumns = `repeat(${SIDE}, 1fr)`;
      boardEl.style.gridTemplateRows = `repeat(${SIDE}, 1fr)`;

      confettiResize();
      for(let r=0;r<SIDE;r++){
        for(let c=0;c<SIDE;c++){
          const v = puzzle[r][c];
          const div = document.createElement("div");
          div.className = "cell";
          div.tabIndex = 0;
          div.dataset.r = r;
          div.dataset.c = c;
          const bIdx = boxIndex(r,c);
          if(bIdx>=0) div.dataset.box = bIdx;

          // âœ… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø®Ù„Ø§ÙŠØ§ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ÙƒØªØ§Ø¨Ø© ÙƒÙ…Ø§ Ø·Ù„Ø¨Øª Ø³Ø§Ø¨Ù‚Ù‹Ø§
          div.dataset.editable = "true";
          div.setAttribute("aria-readonly", "false");
          div.textContent = v!==0 ? v : "";

          // Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠÙ‹Ø§: Ø­Ø¯ÙˆØ¯ Ø³Ù…ÙŠÙƒØ© Ø¨Ø­Ø³Ø¨ Ø´ÙƒÙ„ Ø§Ù„ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„ÙØ¹Ù„ÙŠ (Ù„Ø§ Ù†ØºÙŠÙ‘Ø± CSS Ø§Ù„Ø£ØµÙ„ÙŠ)
          if(BOX_R>1 && (r%BOX_R) === (BOX_R-1)) div.style.borderBottom = "2px solid var(--ink)";
          if(BOX_C>1 && (c%BOX_C) === (BOX_C-1)) div.style.borderRight = "2px solid var(--ink)";

          div.addEventListener("click", ()=> selectCell(div));
          div.addEventListener("keydown", (e)=> handleKey(div, e));
          boardEl.appendChild(div);
        }
      }
      updateProgress();
      status("Ø§Ø¨Ø¯Ø£ â€” Ø§Ù…Ù„Ø£ Ø§Ù„Ø´Ø¨ÙƒØ©!", "info");
      startTimer();
    }

    function readBoardFromDOM(){
      const b = Array.from({length:SIDE}, ()=>Array(SIDE).fill(0));
      $$(".cell").forEach(cell=>{
        const r = +cell.dataset.r, c = +cell.dataset.c;
        const val = cell.textContent.trim();
        b[r][c] = val ? +val : 0;
      });
      return b;
    }

    function writeBoardToDOM(board){
      $$(".cell").forEach(cell=>{
        const r = +cell.dataset.r, c = +cell.dataset.c;
        const v = board[r][c];
        cell.textContent = v===0? "" : v;
      });
    }

    let selected = null;
    function selectCell(cell){
      if(selected) selected.dataset.selected = "false";
      selected = cell;
      selected.dataset.selected = "true";
      selected.classList.add("pop");
      setTimeout(()=> selected.classList.remove("pop"), 120);
    }

    function handleKey(cell, e){
      const editable = cell.dataset.editable === "true";
      if(!editable){
        // allow arrows navigation
        return navKeys(cell, e);
      }
      if(e.key>="1" && e.key<="9"){
        const val = +e.key;
        if(val<=SIDE){
          cell.textContent = e.key;
          cell.classList.remove("wrong");
          cell.classList.add("pop");
          updateProgress();
          playClick();
        }
      }else if(e.key==="Backspace" || e.key==="Delete" || e.key==="0"){
        cell.textContent = "";
        updateProgress();
        playClick();
      }else{
        navKeys(cell, e);
      }
    }

    function navKeys(cell, e){
      const r = +cell.dataset.r, c = +cell.dataset.c;
      let rr=r, cc=c;
      if(e.key==="ArrowUp"){ rr = Math.max(0, r-1); }
      if(e.key==="ArrowDown"){ rr = Math.min(SIDE-1, r+1); }
      if(e.key==="ArrowLeft"){ cc = Math.max(0, c-1); }
      if(e.key==="ArrowRight"){ cc = Math.min(SIDE-1, c+1); }
      if(rr!==r || cc!==c){
        e.preventDefault();
        const next = $(`.cell[data-r="${rr}"][data-c="${cc}"]`);
        if(next){ next.focus(); selectCell(next); }
      }
    }

    /************** Validation **************/
    function checkBoard(){
      // clear marks
      $$(".cell").forEach(c=> c.classList.remove("wrong","correct"));
      const b = readBoardFromDOM();
      let complete = true, ok = true;

      for(let r=0;r<SIDE;r++){
        for(let c=0;c<SIDE;c++){
          const val = b[r][c];
          const cell = $(`.cell[data-r="${r}"][data-c="${c}"]`);
          if(val===0){ complete = false; continue; }
          if(!isValidMove(b, r,c,val)){
            ok = false;
            cell.classList.add("wrong", "shake");
            setTimeout(()=> cell.classList.remove("shake"), 400);
          }
        }
      }

      if(!ok){
        status("Ù‡Ù†Ø§Ùƒ Ø£Ø®Ø·Ø§Ø¡ â€” Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰", "bad");
        return;
      }

      if(complete){
        status("Ù…Ù…ØªØ§Ø²! Ø­Ù„ ØµØ­ÙŠØ­ âœ…", "ok");
        celebrate();
        playWin();
        stopTimer();
        // lock all (Ø§Ø®ØªÙŠØ§Ø±ÙŠ: Ù†Ø¨Ù‚ÙŠÙ‡Ø§ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ÙƒØªØ§Ø¨Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø·Ù„Ø¨Ùƒ Ø§Ù„Ø³Ø§Ø¨Ù‚)
        // $$(".cell").forEach(c=> c.dataset.editable="false");
      }else{
        status("ØµØ­ÙŠØ­ Ø­ØªÙ‰ Ø§Ù„Ø¢Ù† â€” Ø£ÙƒÙ…Ù„ Ø§Ù„Ø¨Ø§Ù‚ÙŠ", "ok");
      }
    }

    function updateProgress(){
      const b = readBoardFromDOM();
      const filled = b.flat().filter(x=>x!==0).length;
      const total = SIDE*SIDE; // Ø¨Ù…Ø§ Ø£Ù† ÙƒÙ„ Ø§Ù„Ø®Ù„Ø§ÙŠØ§ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ÙƒØªØ§Ø¨Ø©
      const pct = Math.max(0, Math.min(100, Math.round((filled/total)*100)));
      progressEl.style.width = pct + "%";
    }

    function status(msg, kind="info"){
      statusEl.textContent = msg;
      statusEl.style.borderColor = {
        info: "var(--cell-border)",
        ok: "var(--ok)",
        bad: "var(--bad)"
      }[kind] || "var(--cell-border)";
      statusEl.style.color = {
        info: "var(--muted)",
        ok: "#2bd576",
        bad: "#ff8a8a"
      }[kind] || "var(--muted)";
    }

    /************** Confetti **************/
    let confettiPieces = [];
    function confettiResize(){
      confettiCanvas.width = boardEl.clientWidth;
      confettiCanvas.height = boardEl.clientHeight;
    }
    function spawnConfetti(n=160){
      const colors = ["#27c93f","#ffcc00","#2f7bff","#ea3b2d","#00d8ff"];
      confettiPieces = Array.from({length:n}, ()=> ({
        x: Math.random()*confettiCanvas.width,
        y: -10 - Math.random()*40,
        r: 2 + Math.random()*4,
        c: colors[Math.floor(Math.random()*colors.length)],
        v: 1 + Math.random()*2.5,
        w: Math.random()*1.5,
        a: Math.random()*Math.PI*2
      }));
    }
    function drawConfetti(){
      ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
      for(const p of confettiPieces){
        p.a += 0.05;
        p.y += p.v;
        p.x += Math.sin(p.a)*p.w;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fillStyle = p.c;
        ctx.fill();
      }
      confettiPieces = confettiPieces.filter(p=> p.y < confettiCanvas.height+10);
      if(confettiPieces.length){
        requestAnimationFrame(drawConfetti);
      }
    }
    function celebrate(){
      spawnConfetti(180);
      drawConfetti();
    }

    /************** Stage Management (6 levels x 10 stages) **************/
    function buildStageSelector(){
      stageSel.innerHTML = "";
      for(let lvl=1; lvl<=6; lvl++){
        for(let st=1; st<=10; st++){
          const opt = document.createElement("option");
          opt.value = `${lvl}-${st}`;
          opt.textContent = `Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${lvl} â€” Ø§Ù„Ù…Ø±Ø­Ù„Ø© ${st}`;
          stageSel.appendChild(opt);
        }
      }
      stageSel.value = `${currentLevel}-${currentStage}`;
    }

    function newStage(level, stage){
      currentLevel = level;
      currentStage = stage;
      [BOX_R, BOX_C] = boxShapeFor(sideForLevel(level));
      SIDE = sideForLevel(level);

      // update board grid template to SIDE
      boardEl.style.gridTemplateColumns = `repeat(${SIDE}, 1fr)`;
      boardEl.style.gridTemplateRows = `repeat(${SIDE}, 1fr)`;

      status(`ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${level} â€” Ø§Ù„Ù…Ø±Ø­Ù„Ø© ${stage}...`);
      const full = generateFull(SIDE, BOX_R, BOX_C);
      solutionBoard = solveBoard(full) || full; // ensure solvable
      // blanks scale with size; keep challenge reasonable
      const density = 0.5; // 50% blanks ØªÙ‚Ø±ÙŠØ¨Ù‹Ø§
      const blanks = Math.round(SIDE*SIDE*density);
      initialBoard = removeCells(solutionBoard, blanks);
      buildBoard(initialBoard);
    }

    function resetStage(){
      writeBoardToDOM(initialBoard);
      status("ØªÙ…Øª Ø§Ù„Ø¥Ø¹Ø§Ø¯Ø© â€” Ø¬Ø±Ù‘Ø¨ Ù…Ù† Ø¬Ø¯ÙŠØ¯");
      startTimer();
      progressEl.style.width = "0%";
    }

    btnCheck.addEventListener("click", checkBoard);
    btnNext.addEventListener("click", ()=>{
      let lvl = currentLevel, st = currentStage + 1;
      if(st>10){ st=1; lvl++; }
      if(lvl>6){ lvl=1; st=1; }
      stageSel.value = `${lvl}-${st}`;
      const [nl, ns] = stageSel.value.split("-").map(Number);
      newStage(nl, ns);
    });
    btnReset.addEventListener("click", resetStage);
    stageSel.addEventListener("change", (e)=>{
      const [lvl, st] = e.target.value.split("-").map(Number);
      newStage(lvl, st);
    });

    window.addEventListener("resize", confettiResize);

    // Init
    (function init(){
      buildStageSelector();
      newStage(1,1);
    })();
  </script>
</body>
</html>
